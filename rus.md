# Осваиваем трансдьюсеры

Что такое «трансдьюсеры»? Использовать их довольно легко, но как они работают
под капотом?

Эта статья объясняет принципы работы трансдьюсеров, игнорируя сами трансдьюсеры.
Вместо их изучения мы рассмотрим две обычные функции — `map` и `filter`. Мы
внимательно исследуем то, как они работают. Мы восхитимся силой функций
высшего порядка, когда дело дойдёт до абстракций. И, если вдруг нам повезёт,
мы попутно взглянем на трансдьюсеры.

Так как мы договорились игнорировать трансдьюсеры, вам не нужно знать о них
ничего, чтобы следовать дальше.

Наконец, я советую вам вам поиграться с примерами кода в консоли прямо во время
чтения этой статьи.

## Сила `reduce`

Вы наверняка знакомы с `map` и `filter`. Также вы наверняка знаете, что их можно
компоновать примерно так:

    (map inc (range 10))
    ; ⇒ (1 2 3 4 5 6 7 8 9 10)

    (filter even? '(1 2 3 4 5 6 7 8 9 10))
    ; ⇒ (2 4 6 8 10)

    (filter even? (map inc (range 10)))
    ; ⇒ (2 4 6 8 10)

Открою вам небольшой секрет: `map` и `filter` можно реализовать с помощью
функции `reduce`. Давайте реализуем выражение `(map inc (range 10))`, используя
`reduce`:

    (defn map-inc-reducer
      [result input]
      (conj result (inc input)))

    (reduce map-inc-reducer [] (range 10))
    ; ⇒ [1 2 3 4 5 6 7 8 9 10]

Обратите внимание, `map-inc-reducer` явно использует `inc` в качестве операции,
трансформирующей значение. Как насчёт того, чтобы дать пользователю возможность
самому задавать правила трансформации значений? Мы можем определить новую
функцию, принимающую функцию для трансформации и возвращающую функцию для
редьюсера:

    (defn map-reducer
      [f]
      (fn [result input]
        (conj result (f input))))

    (reduce (map-reducer inc) [] (range 10))
    ; ⇒ [1 2 3 4 5 6 7 8 9 10]

Функции вроде `map-reducer` называются *функциями высшего порядка*, потому что
они принимают и возвращают функции. Поиграемся ещё немного:

    (reduce (map-reducer dec) [] (range 10))
    ; ⇒ [-1 0 1 2 3 4 5 6 7 8]

    (reduce (map-reducer #(* % %)) [] (range 10))
    ; ⇒ [0 1 4 9 16 25 36 49 64 81]

Теперь давайте реализуем выражение `(filter even? '(1 2 3 4 5 6 7 8 9 10))`,
используя `reduce`:

    (defn filter-even-reducer
      [result input]
      (if (even? input)
        (conj result input)
        result))

    (reduce filter-even-reducer [] '(1 2 3 4 5 6 7 8 9 10))
    ; ⇒ [2 4 6 8 10]

И снова обратим внимание на то, что `filter-even-reducer` явно использует
выражение `even?` в качестве предиката. Как и в прошлом примере,
давайте вынесем предикат наружу, чтобы пользователь сам мог задавать его:

    (defn filter-reducer
      [predicate]
      (fn [result input]
        (if (predicate input)
          (conj result input)
          result)))

    (reduce (filter-reducer even?) [] '(1 2 3 4 5 6 7 8 9 10))
    ; ⇒ [2 4 6 8 10]

Мы даже можем скомпоновать `map-reducer` и `filter-reducer`:

    (reduce
      (filter-reducer even?)
      []
      (reduce
        (map-reducer inc)
        []
        (range 10)))
    ; ⇒ [2 4 6 8 10]

Пример выше эквивалентен следующему примеру (за исключением разницы между
векторами и спискам):

    (filter even? (map inc (range 10)))
    ; ⇒ (2 4 6 8 10)

Мы видим, что с помощью функций высшего порядка можно реализовать `map` и
`filter` на основе `reduce`.

Однако, обе версии кода используют промежуточные коллекции — одну для `map`
и одну для `filter`. Важное свойство трансдьюсеров заключается в том, что
во время выполнения они используют только одну и ту же коллекцию независимо
от количества применяемых трансформаций. Как мы можем добиться этого?

## Погружаемся в абстракции ещё глубже

Давайте внимательно рассмотрим `map-reducer` и `filter-reducer`. Вот они:

    (defn map-reducer
      [f]
      (fn [result input]
        (conj result (f input))))

    (defn filter-reducer
      [predicate]
      (fn [result input]
        (if (predicate input)
          (conj result input)
          result)))

Что вы видите? В каждой из функций используется `conj`. Почему? Что в нём
такого? Можем ли мы использовать что-нибудь другое вместо `conj`?

Заметим, что `result` и `input` могут быть любого типа. Но если `result` будет
равен `10`, а `input` — `1`, `conj` не сработает; `(conj 10 1)` выдаст ошибку.
Вместо `conj` в таком случае следует использовать что-то вроде `+`, потому что
в операции `(+ 10 1)` есть смысл.

Исходя из вышесказанного можно сделать такой вывод: `conj` и `+` — это
*сокращающие функции* (англ. *reducing functions*). Сокращающие функции имеют
вид `result, input -> result`. Они принимают на вход какой-то результат
и входное значение, а возвращают *новый* результат. Например:

    (conj [1 2 3] 4)
    ; ⇒ [1 2 3 4]

    (+ 10 1)
    ; ⇒ 11

Вместо того, чтобы всегда использовать `conj` в `map-reducer`
и `filter-reducer`, мы можем позоволить пользователю самому задавать
сокращающую функцию.

Это выльется в ещё одну функцию высшего порядка, принимающую функцию
трансформации значения в случае с `map` и предикат в случае с `filter`.
Но на этот раз мы вернём функцию, принимающую произвольную сокращающую функцию.
Давайте используем имена `mapping` и `filtering` для наших новых функций:

    (defn mapping
      [f]
      (fn [reducing]
        (fn [result input]
          (reducing result (f input)))))

    (defn filtering
      [predicate]
      (fn [reducing]
        (fn [result input]
          (if (predicate input)
            (reducing result input)
            result))))

И теперь давайте используем их так же, как мы это делали раньше:

    (reduce
      ((filtering even?) conj)
      []
      (reduce
        ((mapping inc) conj)
        []
        (range 10)))
    ; ⇒ [2 4 6 8 10]

По коду выше видно, что мы можем сами выбирать сокращающую функцию (в данном
случае это `conj`).

## Приближаемся к трансдьюсерам

Обратите внимание на функции `((mapping inc) conj)`
и `((filtering even?) conj)`. Они имеют вид `result, input -> result`. Мы можем
проверить это:

    (((mapping inc) conj) [] 1)
    ; ⇒ [2]

    (((mapping inc) conj) [2] 2)
    ; ⇒ [2 3]

    (((mapping inc) conj) [2 3] 3)
    ; ⇒ [2 3 4]

    (((filtering even?) conj) [2 4] 5)
    ; ⇒ [2 4]

    (((filtering even?) conj) [2 4] 6)
    ; ⇒ [2 4 6]

Это означает, что `((mapping inc) conj)` и `((filtering even?) conj)` —
**тоже сокращающие функции**, такие же как `conj` и `+`.

Тогда что произойдёт, если мы скомпонуем эти функции?

    ((mapping inc) ((filtering even?) conj))

Это тоже функция. Но что она из себя представляет и какой результат выдаёт?
Ну же, выполните её в консоли!

Оказывается, эта функция *тоже* имеет вид `result, input -> result`. Она тоже
является сокращающей функцией. Поэтому мы можем использовать её внутри `reduce`:

    (reduce ((mapping inc) ((filtering even?) conj)) [] (range 10))
    ; ⇒ [2 4 6 8 10]

Выглядит немного неаккуратно, поэтому давайте перепишем пример с использованием
`comp`. Напомню, что `(comp a b c d)` возвращает функцию:

    (fn [r] (a (b (c (d r)))))

Вот переписанный с использованием `comp` пример:

    (def xform
      (comp
        (mapping inc)
        (filtering even?)))

    (reduce (xform conj) [] (range 10))
    ; ⇒ [2 4 6 8 10]

Как насчёт чего-то посложнее?

    (defn square [x] (* x x))

    (def xform
      (comp
        (filtering even?) 
        (filtering #(< % 10))
        (mapping square)
        (mapping inc)))

    (reduce (xform conj) [] (range 10))
    ; ⇒ [1 5 17 37 65]

Красота.

Однако, мы отвлеклись от темы. Что же такое трансдьюсеры?

Оказывается, `mapping` и `filtering` — это функции, возвращающие трансдьюсеры.
Функции `(mapping inc)`, `(filtering even?)` и `xform` это те самые
трансдьюсеры, которых вы наверняка с нетерпением ждали.

Трансдьюсер — это функция, принимающая и возвращающая сокращающую функцию.
Например, `(mapping inc)` является трансдьюсером, потому что она принимает
сокращающую функцию `conj` и возвращает тоже сокращающую функцию, как мы увидели
ранее. Рич Хоки верно подметил в статье [Transducers are coming][0], что
трансдьюсеры имеют следующий вид:

    (result, input -> result) -> (result, input -> result)

Также обратите внимание на то, что во время выполнения
`(reduce (xform conj) [] (range 10))` не создаётся никаких промежуточных
коллекций, в отличие от изначальных векторов.

## Более интуитивное понимание
С первого раза сложно понять, почему трансдьюсер `xform` работает, так как он
довольно сложный. Давайте попробуем разобраться. Вот сам `xform`:

    (defn square [x] (* x x))

    (def xform
      (comp
        (filtering even?)
        (filtering #(< % 10))
        (mapping square)
        (mapping inc)))

Вызовем скомпонованную функцию, передав ей какую-нибудь сокращающую функцию —
например, нашу любимую `conj`. Она будет передана в трансдьюсер `(mapping inc)`:
`((mapping inc) conj)`. Мы знаем, что это выражение вернёт новую сокращающую
функцию. Эта новая функция будет передана в другой трансдьюсер,
`(mapping square)`. И снова в результате мы получим сокращающую функцию. И так
будет продолжаться на протяжении всей цепочки трансдьюсеров, вплоть
до `(filtering even?)`.

Это означает, что передав в `xform` какую-либо сокращающую функцию — например,
`(xform conj)` — в результате мы получим функцию, применяющую
к входному значению и результату все сокращающие функции слева направо,
заканчивая самой `conj`.

Представим, что наш трансдьюсер используется в функции `reduce`, и на текущий
момент мы собрали в результате вектор `[1 5 17]`. Представим, что следующим
входным параметром будет `12`. Так как `12` — чётное число, оно успешно пройдёт
первый фильтр. Затем первый фильтр вызовет свою сокращающую функцию, передав
в неё `[1 5 17]` и `12`. В данном случае сокращающей функцией является следующая
трансформация — второй фильтр `#(< % 10)`. Так как `12` не проходит этот фильтр,
третья сокращающая функция *не вызывается* и возвращается результат `[1 5 17]`.

Но если входным значением будет `6`, оно пройдёт оба фильтра и к нему применятся
трансформации, так что на выходе мы получим `37`. Затем это число будет передано
в итоговую сокращающую функцию, `conj`, которая объединит `[1 5 17]` с новым
полученным значением.

    ((xform conj) [1 5 17] 12)
    ; ⇒ [1 5 17]

    ((xform conj) [1 5 17] 6)
    ; ⇒ [1 5 17 37]

    (reduce (xform conj) [] (range 10))
    ; ⇒ [1 5 17 37 65]

В основе компоновки трансдьюсеров лежат простые функции. Эта возможность очень
важна, хоть она и относительно проста в реализации.

## Трансдьюсеры в core.async
Ещё одно ключевое преимущество трансдьюсеров — они могут работать в каналах
`core.async`. Например, мы можем взять наш трансдьюсер `xform` и применить его
для фильтрации и трансформации элементов в канале.

Используем стандартную библиотеку Clojure для работы с трансдьюсерами:

    (defn square [x] (* x x))

    (def xform
      (comp
        (filter even?)
        (filter #(< % 10))
        (map square)
        (map inc)))

    (def my-chan (async/chan 1 xform))

    ; Waiting for an item to print...
    (async/take! my-chan println)

    (async/put! my-chan 3)
    ; nothing printed to screen, since 3 is not even

    (async/put! my-chan 4)
    ; "17" printed to screen, since 4 is even and less than 10

Как трансдьюсеры работают в каналах `core.async`?

Для начала заметим, что буферы каналов на деле являются обычными связными
списками (если быть точным, `java.util.LinkedLists`). Когда вы помещаете
элемент в канал, вызывается внутренний вспомогательный метод `add!`, чтобы
добавить ваш элемент в буфер.

Но если мы используем трансдьюсер `xform`, `core.async` применит `add!`
как сокращающую функцию, переданную в `xform`:

    (xform add!)

Это значит, что любой помещённый в канал элемент в первую очередь будет
трансформирован нашим трансдьюсером. И если элемент не пройдёт фильтры
внутри трансдьюсера (например, `(filter even?)`), итоговая сокращающая функция
`add!` не будет вызвана. Таким образом, отфильтрованный элемент никогда не будет
помещён в буфер канала.

Соответствующий код можно найти в [исходниках `core.async`][1].

## Заключение
Мы прошли большой путь. Мы начали с обычных `map` и `filter`; узнали, как их
можно реализовать с помощью `reduce`. Затем мы абстрагировали наши сокращающие
функции, пока не получили функции для построения трансдьюсеров — `mapping`
и `filtering`.

Надеюсь, что этот путь был вам полезен и вы получили более глубокое понимание
того, как работают трансдьюсеры. В конце концов, это всего лишь функции.

## Задания
Если вы хотите попрактиковаться, рекомендую попробовать решить задания,
представленные ниже. Решения можно найти [здесь][2].

### Напишите вспомогательную функцию `transduce`
На данный момент мы используем `reduce` довольно неудобно. Напишите функцию
`transduce`, которая позволит использовать трансдьюсеры так:

    (transduce xform conj [] (range 10))
    ; ⇒ [5 17 37 65]

### Шифр Цезаря
В примерах выше мы использовали `conj` и `+` как сокращающие функции. Теперь
давайте напишем сокращающую функцию посложнее.

На вход даётся строка. С помощью трансдьюсеров вы должны:

- Отфильтровать все гласные буквы не-ASCII символы;
- Отфильтровать все прописные;
- Применить к оставшейся строке [шифр Цезаря][3];
- С помощью `reduce` привести оставшуюся строку к объекту, содержащему
информацию о количестве вхождений каждого символа в строке.

Пример:

    (defn caesar-count
      [string cipher]
      ???)

    (caesar-count "abc" 0)
    ; ⇒ {\c 1, \b 1}

    (caesar-count "abc" 1)
    ; ⇒ {\d 1, \c 1}

    (caesar-count "hello world" 0)
    ; ⇒ {\d 1, \r 1, \w 1, \l 3, \h 1}

    (caesar-count "hello world" 13)
    ; ⇒ {\q 1, \e 1, \j 1, \y 3, \u 1}

### Напишите трансдьюсер `mapcat`
Напишите функцию `mapcatting`, возвращающую трансдьюсер `mapcat`.

Пример работы `mapcat` (без трансдьюсеров):

    (defn twins [x] [x x])

    (mapcat twins (range 10))
    ; ⇒ (0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9)

Трансдьюсер должен выглядеть примерно так:

    (defn mapcatting [f] ???)

    (reduce ((mapcatting twins) conj) [] (range 10))
    ; ⇒ [0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9]

### Напишите трансдьюсер `take`
Напишите функцию `taking`, возвращающую трансдьюсер `take`.

    (defn taking [n] ???)

    (reduce ((taking 3) conj) [] (range 10))
    ; ⇒ [0 1 2]

В этом задании вам, возможно, придётся сохранять какое-то промежуточное
состояние.

## Ссылки
- [Исходный код примеров][4]
- [Том Эшворф: CSP и трансдьюсеры в JavaScript][5]. Эта статья помогла мне
разобраться в принципах работы трансдьюсеров.
- [Рич Хики: приходит время трансдьюсеров][5]


 [0]: http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming
 [1]: https://github.com/clojure/core.async/blob/ac0f1bfb40237a18dc0f03c0db5df41657cd23a6/src/main/clojure/clojure/core/async/impl/channels.clj#L287
 [2]: https://gist.github.com/elben/da8864e120c373e5fcf0#file-understanding-transducers-clj-L204
 [3]: http://en.wikipedia.org/wiki/Caesar_cipher
 [4]: https://gist.github.com/elben/da8864e120c373e5fcf0
 [5]: http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming
