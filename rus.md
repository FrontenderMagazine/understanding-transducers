# Осваиваем трансдьюсеры

Что такое «трансдьюсеры»? Использовать их довольно легко, но как они работают
под капотом?

Эта статья объясняет принципы работы трансдьюсеров, игнорируя сами трансдьюсеры.
Вместо их изучения мы рассмотрим две обычные функции — `map` и `filter`. Мы
внимательно исследуем то, как они работают. Мы восхитимся силой функций
высшего порядка, когда дело дойдёт до абстракций. И, если вдруг нам повезёт,
мы попутно взглянем на трансдьюсеры.

Так как мы договорились игнорировать трансдьюсеры, вам не нужно знать о них
ничего, чтобы следовать дальше.

Наконец, я советую вам вам поиграться с примерами кода в консоли прямо во время
чтения этой статьи.

## Сила `reduce`

Вы наверняка знакомы с `map` и `filter`. Также вы наверняка знаете, что их можно
компоновать примерно так:

    (map inc (range 10))
    ; ⇒ (1 2 3 4 5 6 7 8 9 10)

    (filter even? '(1 2 3 4 5 6 7 8 9 10))
    ; ⇒ (2 4 6 8 10)

    (filter even? (map inc (range 10)))
    ; ⇒ (2 4 6 8 10)

Открою вам небольшой секрет: `map` и `filter` можно реализовать с помощью
функции `reduce`. Давайте реализуем выражение `(map inc (range 10))`, используя
`reduce`:

    (defn map-inc-reducer
      [result input]
      (conj result (inc input)))

    (reduce map-inc-reducer [] (range 10))
    ; ⇒ [1 2 3 4 5 6 7 8 9 10]

Обратите внимание, `map-inc-reducer` явно использует `inc` в качестве операции,
трансформирующей значение. Как насчёт того, чтобы дать пользователю возможность
самому задавать правила трансформации значений? Мы можем определить новую
функцию, принимающую функцию для трансформации и возвращающую функцию для
редьюсера:

    (defn map-reducer
      [f]
      (fn [result input]
        (conj result (f input))))

    (reduce (map-reducer inc) [] (range 10))
    ; ⇒ [1 2 3 4 5 6 7 8 9 10]

Функции вроде `map-reducer` называются *функциями высшего порядка*, потому что
они принимают и возвращают функции. Поиграемся ещё немного:

    (reduce (map-reducer dec) [] (range 10))
    ; ⇒ [-1 0 1 2 3 4 5 6 7 8]

    (reduce (map-reducer #(* % %)) [] (range 10))
    ; ⇒ [0 1 4 9 16 25 36 49 64 81]

Теперь давайте реализуем выражение `(filter even? '(1 2 3 4 5 6 7 8 9 10))`,
используя `reduce`:

    (defn filter-even-reducer
      [result input]
      (if (even? input)
        (conj result input)
        result))

    (reduce filter-even-reducer [] '(1 2 3 4 5 6 7 8 9 10))
    ; ⇒ [2 4 6 8 10]

И снова обратим внимание на то, что `filter-even-reducer` явно использует
выражение `even?` в качестве предиката. Как и в прошлом примере,
давайте вынесем предикат наружу, чтобы пользователь сам мог задавать его:

    (defn filter-reducer
      [predicate]
      (fn [result input]
        (if (predicate input)
          (conj result input)
          result)))

    (reduce (filter-reducer even?) [] '(1 2 3 4 5 6 7 8 9 10))
    ; ⇒ [2 4 6 8 10]

Мы даже можем скомпоновать `map-reducer` и `filter-reducer`:

    (reduce
      (filter-reducer even?)
      []
      (reduce
        (map-reducer inc)
        []
        (range 10)))
    ; ⇒ [2 4 6 8 10]

Пример выше эквивалентен следующему примеру (за исключением разницы между векторами и спискам):

    (filter even? (map inc (range 10)))
    ; ⇒ (2 4 6 8 10)

Мы видим, что с помощью функций высшего порядка можно реализовать `map` и
`filter` на основе `reduce`.

Однако, обе версии кода используют промежуточные коллекции — одну для `map` и одну для `filter`.
Важное свойство трансдьюсеров заключается в том, что во время выполнения они используют только одну
и ту же коллекцию независимо от количества применяемых трансформаций. Как мы можем добиться этого?

## Погружаемся в абстракции ещё глубже

Давайте внимательно рассмотрим `map-reducer` и `filter-reducer`. Вот они:

    (defn map-reducer
      [f]
      (fn [result input]
        (conj result (f input))))

    (defn filter-reducer
      [predicate]
      (fn [result input]
        (if (predicate input)
          (conj result input)
          result)))

Что вы видите? В каждой из функций используется `conj`. Почему? Что в нём такого? Можем ли мы
использовать что-нибудь другое вместо `conj`?

Заметим, что `result` и `input` могут быть любого типа. Но если `result` будет равен `10`, а
`input` — `1`, `conj` не сработает; `(conj 10 1)` выдаст ошибку. Вместо `conj` в таком случае
следует использовать что-то вроде `+`, потому что в операции `(+ 10 1)` есть смысл.

Исходя из вышесказанного можно сделать такой вывод: `conj` и `+` — это *сокращающие функции* 
(англ. *reducing functions*). Сокращающие функции имеют вид `result, input -> result`. Они принмают
на вход какой-то результат и входное значение, а возвращают *новый* результат. Например:

    (conj [1 2 3] 4)
    ; ⇒ [1 2 3 4]

    (+ 10 1)
    ; ⇒ 11

Вместо того, чтобы всегда использовать `conj` в `map-reducer` и `filter-reducer`, мы можем
позоволить пользователю самому задавать сокращающую функцию.

Это выльется в ещё одну функцию высшего порядка, принимающую функцию трансформации значения в случае
с `map` и предикат в случае с `filter`. Но на этот раз мы вернём функцию, принимающую произвольную
сокращающую функцию. Давайте используем имена `mapping` и `filtering` для наших новых функций:

    (defn mapping
      [f]
      (fn [reducing]
        (fn [result input]
          (reducing result (f input)))))

    (defn filtering
      [predicate]
      (fn [reducing]
        (fn [result input]
          (if (predicate input)
            (reducing result input)
            result))))

И теперь давайте используем их так же, как мы это делали раньше:

    (reduce
      ((filtering even?) conj)
      []
      (reduce
        ((mapping inc) conj)
        []
        (range 10)))
    ; ⇒ [2 4 6 8 10]
