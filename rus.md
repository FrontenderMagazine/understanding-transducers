# Осваиваем трансдьюсеры

Что такое «трансдьюсеры»? Использовать их довольно легко, но как они работают
под капотом?

Эта статья объясняет принципы работы трансдьюсеров, игнорируя сами трансдьюсеры.
Вместо их изучения мы рассмотрим две обычные функции — `map` и `filter`. Мы
внимательно исследуем то, как они работают. Мы восхитимся силой функций
высшего порядка, когда дело дойдёт до абстракций. И, если вдруг нам повезёт,
мы попутно взглянем на трансдьюсеры.

Так как мы договорились игнорировать трансдьюсеры, вам не нужно знать о них
ничего, чтобы следовать дальше.

Наконец, я советую вам вам поиграться с примерами кода в консоли прямо во время
чтения этой статьи.

## Сила `reduce`

Вы наверняка знакомы с `map` и `filter`. Также вы наверняка знаете, что их можно
компоновать примерно так:

    (map inc (range 10))
    ; ⇒ (1 2 3 4 5 6 7 8 9 10)

    (filter even? '(1 2 3 4 5 6 7 8 9 10))
    ; ⇒ (2 4 6 8 10)

    (filter even? (map inc (range 10)))
    ; ⇒ (2 4 6 8 10)

Открою вам небольшой секрет: `map` и `filter` можно реализовать с помощью
функции `reduce`. Давайте реализуем выражение `(map inc (range 10))`, используя
`reduce`:

    (defn map-inc-reducer
      [result input]
      (conj result (inc input)))

    (reduce map-inc-reducer [] (range 10))
    ; ⇒ [1 2 3 4 5 6 7 8 9 10]

Обратите внимание, `map-inc-reducer` явно использует `inc` в качестве операции,
трансформирующей значение. Как насчёт того, чтобы дать пользователю возможность
самому задавать правила трансформации значений? Мы можем определить новую
функцию, принимающую функцию для трансформации и возвращающую функцию для
редьюсера:

    (defn map-reducer
      [f]
      (fn [result input]
        (conj result (f input))))

    (reduce (map-reducer inc) [] (range 10))
    ; ⇒ [1 2 3 4 5 6 7 8 9 10]

Функции вроде `map-reducer` называются *функциями высшего порядка*, потому что
они принимают и возвращают функции. Поиграемся ещё немного:

    (reduce (map-reducer dec) [] (range 10))
    ; ⇒ [-1 0 1 2 3 4 5 6 7 8]

    (reduce (map-reducer #(* % %)) [] (range 10))
    ; ⇒ [0 1 4 9 16 25 36 49 64 81]

Теперь давайте реализуем выражение `(filter even? '(1 2 3 4 5 6 7 8 9 10))`,
используя `reduce`:

    (defn filter-even-reducer
      [result input]
      (if (even? input)
        (conj result input)
        result))

    (reduce filter-even-reducer [] '(1 2 3 4 5 6 7 8 9 10))
    ; ⇒ [2 4 6 8 10]

И снова обратим внимание на то, что `filter-even-reducer` явно использует
выражение `even?` в качестве предиката. Как и в прошлом примере,
давайте вынесем предикат наружу, чтобы пользователь сам мог задавать его:

    (defn filter-reducer
      [predicate]
      (fn [result input]
        (if (predicate input)
          (conj result input)
          result)))

    (reduce (filter-reducer even?) [] '(1 2 3 4 5 6 7 8 9 10))
    ; ⇒ [2 4 6 8 10]

Мы даже можем скомпоновать `map-reducer` и `filter-reducer`:

    (reduce
      (filter-reducer even?)
      []
      (reduce
        (map-reducer inc)
        []
        (range 10)))
    ; ⇒ [2 4 6 8 10]

Пример выше эквивалентен следующему примеру (за исключением разницы между
векторами и спискам):

    (filter even? (map inc (range 10)))
    ; ⇒ (2 4 6 8 10)

Мы видим, что с помощью функций высшего порядка можно реализовать `map` и
`filter` на основе `reduce`.

Однако, обе версии кода используют промежуточные коллекции — одну для `map`
и одну для `filter`. Важное свойство трансдьюсеров заключается в том, что
во время выполнения они используют только одну и ту же коллекцию независимо
от количества применяемых трансформаций. Как мы можем добиться этого?

## Погружаемся в абстракции ещё глубже

Давайте внимательно рассмотрим `map-reducer` и `filter-reducer`. Вот они:

    (defn map-reducer
      [f]
      (fn [result input]
        (conj result (f input))))

    (defn filter-reducer
      [predicate]
      (fn [result input]
        (if (predicate input)
          (conj result input)
          result)))

Что вы видите? В каждой из функций используется `conj`. Почему? Что в нём
такого? Можем ли мы использовать что-нибудь другое вместо `conj`?

Заметим, что `result` и `input` могут быть любого типа. Но если `result` будет
равен `10`, а `input` — `1`, `conj` не сработает; `(conj 10 1)` выдаст ошибку.
Вместо `conj` в таком случае следует использовать что-то вроде `+`, потому что
в операции `(+ 10 1)` есть смысл.

Исходя из вышесказанного можно сделать такой вывод: `conj` и `+` — это
*сокращающие функции* (англ. *reducing functions*). Сокращающие функции имеют
вид `result, input -> result`. Они принимают на вход какой-то результат
и входное значение, а возвращают *новый* результат. Например:

    (conj [1 2 3] 4)
    ; ⇒ [1 2 3 4]

    (+ 10 1)
    ; ⇒ 11

Вместо того, чтобы всегда использовать `conj` в `map-reducer`
и `filter-reducer`, мы можем позоволить пользователю самому задавать
сокращающую функцию.

Это выльется в ещё одну функцию высшего порядка, принимающую функцию
трансформации значения в случае с `map` и предикат в случае с `filter`.
Но на этот раз мы вернём функцию, принимающую произвольную сокращающую функцию.
Давайте используем имена `mapping` и `filtering` для наших новых функций:

    (defn mapping
      [f]
      (fn [reducing]
        (fn [result input]
          (reducing result (f input)))))

    (defn filtering
      [predicate]
      (fn [reducing]
        (fn [result input]
          (if (predicate input)
            (reducing result input)
            result))))

И теперь давайте используем их так же, как мы это делали раньше:

    (reduce
      ((filtering even?) conj)
      []
      (reduce
        ((mapping inc) conj)
        []
        (range 10)))
    ; ⇒ [2 4 6 8 10]

По коду выше видно, что мы можем сами выбирать сокращающую функцию (в данном
случае это `conj`).

## Приближаемся к трансдьюсерам

Обратите внимание на функции `((mapping inc) conj)`
и `((filtering even?) conj)`. Они имеют вид `result, input -> result`. Мы можем
проверить это:

    (((mapping inc) conj) [] 1)
    ; ⇒ [2]

    (((mapping inc) conj) [2] 2)
    ; ⇒ [2 3]

    (((mapping inc) conj) [2 3] 3)
    ; ⇒ [2 3 4]

    (((filtering even?) conj) [2 4] 5)
    ; ⇒ [2 4]

    (((filtering even?) conj) [2 4] 6)
    ; ⇒ [2 4 6]

Это означает, что `((mapping inc) conj)` и `((filtering even?) conj)` —
**тоже сокращающие функции**, такие же как `conj` и `+`.

Тогда что произойдёт, если мы скомпонуем эти функции?

    ((mapping inc) ((filtering even?) conj))

Это тоже функция. Но что она из себя представляет и какой результат выдаёт?
Ну же, выполните её в консоли!

Оказывается, эта функция *тоже* имеет вид `result, input -> result`. Она тоже
является сокращающей функцией. Поэтому мы можем использовать её внутри `reduce`:

    (reduce ((mapping inc) ((filtering even?) conj)) [] (range 10))
    ; ⇒ [2 4 6 8 10]

Выглядит немного неаккуратно, поэтому давайте перепишем пример с использованием
`comp`. Напомню, что `(comp a b c d)` возвращает функцию:

    (fn [r] (a (b (c (d r)))))

Вот переписанный с использованием `comp` пример:

    (def xform
      (comp
        (mapping inc)
        (filtering even?)))

    (reduce (xform conj) [] (range 10))
    ; ⇒ [2 4 6 8 10]

Как насчёт чего-то посложнее?

    (defn square [x] (* x x))

    (def xform
      (comp
        (filtering even?) 
        (filtering #(< % 10))
        (mapping square)
        (mapping inc)))

    (reduce (xform conj) [] (range 10))
    ; ⇒ [1 5 17 37 65]

Красота.

Однако, мы отвлеклись от темы. Что же такое трансдьюсеры?

Оказывается, `mapping` и `filtering` — это функции, возвращающие трансдьюсеры.
Функции `(mapping inc)`, `(filtering even?)` и `xform` это те самые
трансдьюсеры, которых вы наверняка с нетерпением ждали.

Трансдьюсер — это функция, принимающая и возвращающая сокращающую функцию.
Например, `(mapping inc)` является трансдьюсером, потому что она принимает
сокращающую функцию `conj` и возвращает тоже сокращающую функцию, как мы увидели
ранее. Рич Хоки верно подметил в статье [Transducers are coming][0], что
трансдьюсеры имеют следующий вид:

    (result, input -> result) -> (result, input -> result)

Также обратите внимание на то, что во время выполнения
`(reduce (xform conj) [] (range 10))` не создаётся никаких промежуточных
коллекций, в отличие от изначальных векторов.

 [0]: http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming
